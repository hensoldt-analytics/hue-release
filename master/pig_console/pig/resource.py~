import os
from datetime import datetime
from django.db import IntegrityError
from django.contrib.auth.models import Group
from django.db.models import Q, Max
from django.core.exceptions import ObjectDoesNotExist
from django.contrib.contenttypes.models import ContentType
from django.conf import settings

from tastypie import http
from tastypie import fields
from tastypie.exceptions import BadRequest, ImmediateHttpResponse
from tastypie.utils import dict_strip_unicode_keys
from tastypie.resources import ModelResource, ALL, ALL_WITH_RELATIONS

#from apps.api.tests import update_data
from apps.api.utils import (
    BaseModelResource, PutModelResource, DjangoAuthentication,
    DjangoAuthorization, abort, AllAuthorization, MixinResource)
from apps.quizzes.models import (
    Quiz, QuizQuestion, QuizQuestionAnswer, QuizAssigment, QuizResults)
from apps.translators.models import Translator, TranslationAssignment

from apps.video.models import Video, ConvertVideo, VideoGroup
from apps.puppets.models import Puppet, QuizPuppet, QuizPuppetTranslation

from apps.presentations.models import (
    Presentation, PresentationSlide, SlideTextBlock)
from apps.core.models import (Language, Vendor, VendorBackgroundImage,
    VendorGroup, VendorGroupImage, VendorGroupTranslation, VendorContentIntro,
    InfoPageTranslation, InfoPage)
from apps.seminar.models import Seminar, SeminarContentItem, SeminarMedia
from apps.grid_access.models import GridAccess
from tastypie.serializers import Serializer

__all__ = [
    'LanguageResource', 'VendorResource', 'VendorGroupResource',
    'VendorBackgroundImageResource', 'SlideTextBlockResource', 'PuppetResource',
    'PresentationResource', 'PresentationSlideResource', 'TranslatorResource',
    'TranslationAssignmentResource', 'QuizResource', 'QuizQuestionResource', 'QuizAssigmentResource',
    'QuizResultsResource', 'VideoResource', 'ContentPagesResource',
    'SeminarResource', 'SeminarContentResource', 'SeminarMediaResource',
    'QuizGroupResource', 'VideoGroupResource', 'QuizPuppetResource',
    'VendorContentIntroResource']

managers = Group.objects.get(name='managers')
def_lang = Language.objects.get(is_default=True)
excludes = ['tree_id', 'rght', 'level', 'lft']


class CustomSerializer(Serializer):

    def format_datetime(self, data):
        return data.date().ctime()


class LanguageResource(ModelResource):
    # parent = fields.ToOneField('self', 'parent', null=True)
    class Meta:
        queryset = Language.objects.all()
        resource_name = 'language_resource'
        list_allowed_methods = ['get']
        detail_allowed_methods = ['get']
        serializer = CustomSerializer()
        include_resource_uri = False
        excludes = excludes
        filtering = {"code": ('exact', ),
                     "id": ALL}

    def get_object_list(self, request=None):
        result = super(LanguageResource, self).get_object_list(request)
        return result.filter(parent__isnull=True, is_visible=True)

    def dehydrate(self, bundle):
        obj_id = bundle.data['id']
        bundle.data['children'] = tuple(Language.objects.filter(
            is_visible=True,
            parent=obj_id).values())
        return super(LanguageResource, self).dehydrate(bundle)


class VendorContentIntroResource(ModelResource):
    language = fields.ToOneField(LanguageResource, 'language')
    vendor = fields.ToOneField('apps.api.resource.VendorResource', 'vendor')

    class Meta:
        queryset = VendorContentIntro.objects.all()
        resource_name = 'vendor_content_resource'
        allowed_methods = ['get']
        include_resource_uri = False
        serializer = CustomSerializer()
        filtering = {'id': ALL,
                     'language': ALL_WITH_RELATIONS}

    def build_filters(self, filters=None):
        if not filters.get('language__code'):
            filters.update({'language__code': def_lang.code})
        return super(VendorContentIntroResource, self).build_filters(filters)


class VendorResource(ModelResource):
    # welcome_info = fields.ToManyField(VendorContentIntroResource,
    #                                   'vendorcontentintro_set')
    class Meta:
        queryset = Vendor.objects.all()
        resource_name = 'vendor_resource'
        allowed_methods = ['get']
        include_resource_uri = False
        serializer = CustomSerializer()
        filtering = {"id": ALL}

    def dehydrate(self, bundle):
        language = bundle.request.GET.get('language_code', def_lang.code)
        obj_id = bundle.data['id']
        bundle.data['welcome_info'] = tuple(VendorContentIntro.objects.filter(
            vendor_id=obj_id, language__code=language).values())
        return super(VendorResource, self).dehydrate(bundle)


class VendorBackgroundImageResource(ModelResource):
    vendor = fields.ToOneField('apps.api.resource.VendorResource', 'vendor')

    class Meta:
        queryset = VendorBackgroundImage.objects.all()
        resource_name = 'vendor_background_image_resource'
        list_allowed_methods = ['get']
        detail_allowed_methods = []
        serializer = CustomSerializer()
        include_resource_uri = False
        filtering = {"vendor": ALL_WITH_RELATIONS}

    def build_filters(self, filters=None):
        filters.get('vendor__id') or abort(BadRequest("Invalid data sent."))
        return super(VendorBackgroundImageResource, self).build_filters(filters)


class VendorGroupResource(BaseModelResource):

    class Meta:
        queryset = VendorGroup.objects.all()
        resource_name = 'vendor_group'
        list_allowed_methods = ['get']
        detail_allowed_methods = []
        serializer = CustomSerializer()
        include_resource_uri = False
        filtering = {'id': ALL,
                     'vendor_id': ['exact'],
                     'group_type': ALL}

    def _in_grid_access(self, result):
        datetime_now = datetime.now()
        result_ids = result.values_list('id', flat=True)
        ct = ContentType.objects.get_for_model(VendorGroup)
        object_ids = GridAccess.objects.filter(content_type=ct,
                                               object_id__in=result_ids,
                                               language__code=self.language,
                                               device='web'). \
            filter(
            Q(date_available_start__lt=datetime_now) | \
            Q(date_available_start__isnull=True),
            Q(date_available_end__gt=datetime_now) | \
            Q(date_available_end__isnull=True)).values_list('object_id',
                                                            flat=True)
        return result.filter(id__in=object_ids)

    def get_object_list(self, request=None):
        self.language = request.GET.get('language_code', def_lang.code)

        if 'vendor_id' not in request.GET:
            abort(BadRequest("Invalid data sent."))

        vendor_id = request.GET['vendor_id']
        query_dict = {'vendor_id': vendor_id}

        group_type = request.GET.getlist('group_type')
        if len(group_type) > 0:
            query_dict['group_type__in'] = group_type

        vg = VendorGroup.objects.filter(**query_dict)

        return self._in_grid_access(vg)

    def dehydrate(self, bundle):
        vgt = bundle.obj.vendorgrouptranslation_set.filter(language__code=self.language)
        if not vgt:
            vgt = bundle.obj.vendorgrouptranslation_set.filter(language__code=def_lang.code)

        bundle.data.update(vgt.values("name", "description", "name_sound")[0])
        bundle.data['images'] = tuple(bundle.obj.vendorgroupimage_set.all().values('id', 'image'))
        parent_id = bundle.obj.parent_id
        has_children = True
        if parent_id:
            has_children = False
        bundle.data.update({'has_children': has_children,
                            'parent_id': parent_id})
        return super(VendorGroupResource, self).dehydrate(bundle)


class QuizGroupResource(VendorGroupResource):

    class Meta:
        queryset = VendorGroup.objects.all()
        resource_name = 'quiz_group_resource'
        list_allowed_methods = ['get']
        serializer = CustomSerializer()
        detail_allowed_methods = []

    def get_object_list(self, request=None):
        vendor_id = request.GET.get('vendor_id', False) or \
                    abort(BadRequest("Invalid data sent."))
        self.language = request.GET.get('language_code', def_lang.code)

        quiz = Quiz.objects.filter(vendor_id=vendor_id,
                                   language__code=self.language)
        parent = list(quiz.values_list('parent__presentation__group_id', flat=True))
        presentation = list(quiz.values_list('presentation__group_id', flat=True))
        parent.extend(presentation)
        vendor_ids = [item for item in parent if item]
        vg = VendorGroup.objects.filter(id__in=vendor_ids)
        return self._in_grid_access(vg)


class TranslatorResource(BaseModelResource):

    class Meta:
        queryset = Translator.objects.all()
        resource_name = 'translators_resource'
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization('TranslatorResource')
        serializer = CustomSerializer()
        list_allowed_methods = ['get']
        detail_allowed_methods = []

    def get_object_list(self, request=None):
        language = request.GET.get('language_code', False)
        language and language not in Language.objects.values_list(
            'code', flat=True) and abort(BadRequest("Invalid data sent."))
        result = not language and self._meta.queryset or \
                 Translator.objects.filter(languages__code=language)
        return result

    def dehydrate(self, bundle):
        translator = Translator.objects.get(id=bundle.data['id'])
        bundle.data['translator'] = translator.user
        bundle.data['languages'] = [
            item.code for item in translator.languages.all()]
        return super(TranslatorResource, self).dehydrate(bundle)


class PuppetResource(BaseModelResource):

    class Meta:
        queryset = Puppet.objects.all()
        resource_name = 'puppets_resource'
        serializer = CustomSerializer()
        list_allowed_methods = ['get']
        detail_allowed_methods = []

    def dehydrate(self, bundle):
        puppet_images = bundle.obj.puppetimages_set.all()
        img_count = puppet_images.count()
        if puppet_images:
            puppet_img = puppet_images[0]
            url_img_prefix = '{0}'.format(puppet_img.image.url.split('0')[0])
        else:
            url_img_prefix = ''
        bundle.data['img_count'] = img_count
        bundle.data['url_img_prefix'] = url_img_prefix
        return super(PuppetResource, self).dehydrate(bundle)


class QuizPuppetResource(BaseModelResource):

    class Meta:
        queryset = QuizPuppet.objects.all()
        resource_name = 'quiz_puppets_resource'
        serializer = CustomSerializer()
        list_allowed_methods = ['get']
        detail_allowed_methods = []
        filtering = {'action': ALL}

    def dehydrate(self, bundle):
        language_code = bundle.request.GET.get('language_code', settings.LANGUAGE_CODE)
        try:
            quiz_puppet_trans = bundle.obj.quizpuppettranslation_set\
                                          .get(language__code=language_code)
        except QuizPuppetTranslation.DoesNotExist:
            quiz_puppet_trans = bundle.obj.quizpuppettranslation_set\
                                          .get(language__code=settings.LANGUAGE_CODE)
        bundle.data['text'] = quiz_puppet_trans.text
        bundle.data['sound'] = quiz_puppet_trans.sound.url
        return super(QuizPuppetResource, self).dehydrate(bundle)


class PresentationResource(ModelResource):

    class Meta:
        queryset = Presentation.objects.all()
        resource_name = 'presentation_resource'
        allowed_methods = ['get']
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()
        serializer = CustomSerializer()
        ordering = ['order']

    def slide_fields(self, filters):
        fields, result = ['puppet_text', 'title', 'text', 'audio_notes',
                          'special_title_tags', 'special_slide_tags'], []
        search_type = filters.get('search_type', '')
        if 'audio-text-content' in search_type:
            result.append('audio_notes')
        if 'tags' in search_type:
            [result.append(item) for item in fields if 'tag' in item]
        if 'text-in-slides' in search_type:
            result.append('text')

        if not search_type:
            result.extend(fields)

        return result

    def _in_grid_access(self, result):
        datetime_now = datetime.now()
        result_ids = result.values_list('parent_id', 'language__code')
        ct = ContentType.objects.get_for_model(self._meta.object_class)

        object_ids = GridAccess.objects.filter(content_type=ct).filter(
            Q(date_available_start__lt=datetime_now) | \
            Q(date_available_start__isnull=True),
            Q(date_available_end__gt=datetime_now) | \
            Q(date_available_end__isnull=True)).values_list('object_id',
                                                            'language__code')
        model_ids = dict(set(object_ids) & set(result_ids))
        return result.filter(parent_id__in=model_ids.keys(),
                             language__code__in=model_ids.values())

    def build_search(self, filters, orm_filters):
        presentations_ids = Presentation.objects.filter(**orm_filters).values_list('id', flat=True)
        slides_orm_filters = {}
        slides_orm_filters['presentation__id__in'] = presentations_ids
        slides_orm_filters['presentation__group__group_type'] = 'base'

        slide_ids = PresentationSlide.objects.filter(**slides_orm_filters) \
            .values_list('id', flat=True)
        text_blocks_ids = SlideTextBlock.objects.filter(presentation_slide__id__in=slide_ids,
                                                        text__icontains=filters['q'],
            ).values_list('presentation_slide__id', flat=True)

        presentation_ids_with_text_blocks = PresentationSlide.objects \
            .filter(is_visible=True, id__in=text_blocks_ids).values_list('presentation__id', flat=True)

        for slide_field in self.slide_fields(filters):
            slides_orm_filters['%s__icontains' % slide_field] = filters['q']


        presentation_ids_with_slide = PresentationSlide.objects.filter(**slides_orm_filters).values_list('presentation__id', flat=True)

        return {'id__in': set(list(presentation_ids_with_text_blocks) +
                              list(presentation_ids_with_slide))}

    def build_filters(self, filters=None):
        orm_filters = super(PresentationResource, self).build_filters(filters)

        if 'language_code' not in filters:
            abort(BadRequest("Invalid data sent: language_code is mandatory parameter"))
        else:
            orm_filters['language__code'] = filters['language_code']

        if 'group_id' in filters:
            orm_filters['group__id'] = int(filters[u'group_id'])

        if 'vendor_id' in filters:
            orm_filters['group__vendor__id'] = int(filters[u'vendor_id'])

        orm_filters['is_visible'] = True

        group_type = filters.get(u'group_type', 'base')
        orm_filters['group__group_type'] = group_type

        if 'q' in filters:
            serch_filters = self.build_search(filters, orm_filters)
            orm_filters.update(serch_filters)

        return orm_filters

    def dehydrate(self, bundle):
        bundle.data.get('odp_path', False) and bundle.data.pop('odp_path')
        bundle.data['language'] = bundle.obj.language.code
        return super(PresentationResource, self).dehydrate(bundle)


class PresentationSlideResource(PutModelResource, MixinResource):

    parametr_list = [('language_code', 'presentation__language__code'),
                     ('slide_ids', 'id__in'),
                     ('slide_id', 'id'),
                     ('presentation_ids', 'presentation_id__in'),
                     ('presentation', 'presentation_id')]
    valid_list = [('presentation_id', 'presentation__language__code', ),
                  ('id', )]
    sub_sets = {'slidetextblock_set': ['text']}

    class Meta:
        queryset = PresentationSlide.objects.all()
        resource_name = 'slide_resource'
        allowed_methods = ['get', 'put']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()

    def get_search(self, request, **kwargs):
        sqs = super(PresentationSlideResource, self).get_search(request,
                                                                **kwargs)
        sqs = sqs.filter(presentation__group__group_type='base',
                         is_visible=True)
        result = list()
        for item in kwargs['result']:
            result.extend(item.slidetextblock_set.filter(
                **{'text__icontains': kwargs['q']}).values_list(
                              'presentation_slide_id', flat=True))
        return sqs | self._meta.object_class.objects.filter(
            id__in=result, presentation__group__group_type='base')

    def actual_field(self, request):
        search_type, fields = request.GET.get('search_type', ''), {}
        'audio-text-content' in search_type and fields.update(
            {'audio_notes': self.fields['audio_notes']})
        'tags' in search_type and [fields.update({item: self.fields[item]}) \
             for item in self.fields.keys() if 'tag' in item]
        'text-in-slides' in search_type and fields.update(
            {'text': self.fields['text']})
        not search_type and fields.update(self.fields)
        return fields

    def get_object_list(self, request=None):
        q = request.GET.get('q', '')
        self.valid_list = q and [('presentation__language__code', ), ('id', )] \
                          or self.valid_list
        result = super(PresentationSlideResource, self).get_object_list(request)
        if q:
            search_q = self.get_search(request, q=q, result=result)
            return search_q

        result = result.filter(is_visible=True)
        return result

    def dehydrate(self, bundle):
        slide = bundle.obj
        bundle.data.update({
            'puppet_id': slide.puppet_id,
            'puppet_version': getattr(
                getattr(slide, 'puppet', None), 'version', None),
            'presentation_id': slide.presentation_id})
        bundle.data['text_bloks'] = tuple(SlideTextBlock.objects.filter(
            presentation_slide=bundle.data['id']).values())
        return super(PresentationSlideResource, self).dehydrate(bundle)


class SlideTextBlockResource(PutModelResource):

    parametr_list = [('textblock_id', 'id'),
                     ('slide_id', 'presentation_slide_id'),
                     ('presentation_id', 'presentation_slide__presentation_id')]
    valid_list = [('presentation_slide_id',
                   'presentation_slide__presentation_id', ), ('id', )]

    class Meta:
        queryset = SlideTextBlock.objects.all()
        resource_name = 'textblocks_resource'
        allowed_methods = ['get', 'put']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()


class TranslationAssignmentResource(PutModelResource):

    parametr_list = [('assignment_ids', 'id__in', ),
                     ('translator', 'translator_id', ),
                     ('presentation', 'presentation_id', ),
                     ('assignment_id', 'id', ),
                     ('language_code', 'language__code', )]
    valid_list = [('language__code', ), ('id', ), []]

    class Meta:
        queryset = TranslationAssignment.objects.all()
        resource_name = 'assignment_resource'
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization('TranslationAssignment')

    def dehydrate(self, bundle):
        bundle.data.update(TranslationAssignment.objects.filter(
            id=bundle.data['id']).values('translator_id', 'presentation_id',
                                         'language__code')[0])
        return super(TranslationAssignmentResource, self).dehydrate(bundle)


class QuizResource(MixinResource, ModelResource):

    vendor = fields.ToOneField('apps.api.resource.VendorResource', 'vendor')
    language = fields.ToOneField(LanguageResource, 'language')
    presentation = fields.ToOneField(PresentationResource, 'presentation',
                                     null=True)

    class Meta:
        queryset = Quiz.objects.all()
        resource_name = 'quiz_resource'
        allowed_methods = ['get']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()
        excludes = excludes + ['parent']
        include_resource_uri = False
        filtering = {"vendor": ALL_WITH_RELATIONS,
                     "language": ALL_WITH_RELATIONS,
                     "presentation": ALL_WITH_RELATIONS,
                     'id': ALL}

    def build_filters(self, filters=None):
        if not filters.get('language__code'):
            filters.update({'language__code': def_lang.code})
        return super(QuizResource, self).build_filters(filters)

    # def build_filters(self, filters=None):
    #     print filters
    #     self.group = filters.get('group_id')
    #     self.group or abort(BadRequest("Invalid data sent."))
    #         filters.update({'parent__presentation__group__id': group,
    #                         'presentation__group__id': group})
    #     del filters['group_id']
    #     return super(QuizResource, self).build_filters(filters)

    def get_search(self, request, **kwargs):
        sqs = super(QuizResource, self).get_search(request, **kwargs)
        result = list()
        for item in kwargs['result']:
            result.extend(item.quizquestion_set.filter(
                **{'text__icontains': kwargs['q']}).values_list('quiz_id',
                                                                flat=True))
            sqs = sqs | self._meta.object_class.objects.filter(id__in=result)
            question_result = list()
            for question in item.quizquestion_set.all():
                question_result.extend(question.quizquestionanswer_set.filter(
                    **{'text__icontains': kwargs['q']}).values_list(
                                           'question__quiz_id', flat=True))
            sqs = sqs | self._meta.object_class.objects.filter(
                id__in=question_result)

        return sqs

    # def _in_grid_access(self, result):
    #     import datetime
    # 
    #     datetime_now = datetime.date.today()
    #     result_ids = result.values_list('parent_id', 'language__code')
    #     ct = ContentType.objects.get_for_model(self._meta.object_class)
    # 
    #     object_ids = GridAccess.objects.filter(content_type=ct).filter(
    #         Q(date_available_start__lt=datetime_now) | \
    #         Q(date_available_start__isnull=True),
    #         Q(date_available_end__gt=datetime_now) | \
    #         Q(date_available_end__isnull=True)).values_list('object_id',
    #                                                         'language__code')
    #     model_ids = dict(set(object_ids) & set(result_ids))
    #     return result.filter(parent_id__in=model_ids.keys(),
    #                          language__code__in=model_ids.values())

    def get_object_list(self, request=None):
        result = super(QuizResource, self).get_object_list(request)
        if request.method.lower() == 'get' and 'group_id' in request.GET:
            group_id = request.GET['group_id']
            result = result.filter(
                Q(parent__presentation__group_id=group_id) | \
                Q(presentation__group_id=group_id))
        q = request.GET.get('q', '')
        if q:
            return self.get_search(request, q=q, result=result)
        return result#self._in_grid_access(result)

    # def dehydrate(self, bundle):
    #     try:
    #         quiz_id = int(bundle.request.path.split('/')[-1])
    #     except ValueError:
    #         return super(QuizResource, self).dehydrate(bundle)
    # 
    #     args = managers in bundle.request.user.groups.all() and (
    #         'text', 'sound', 'media_file', 'is_correct', ) or (
    #         'text', 'sound', 'media_file', )
    #     questions = QuizQuestion.objects.filter(quiz_id=quiz_id).values()
    #     ques_data = [
    #         update_data(item, {'answers': QuizQuestionAnswer.objects.filter(
    #         question_id=item['id']).values(*args)}) for item in questions]
    #     bundle.data.update({'questions': ques_data})
    #     return super(QuizResource, self).dehydrate(bundle)


class QuizQuestionResource(ModelResource):

    class Meta:
        queryset = QuizQuestion.objects.all()
        resource_name = 'quiz_question_resource'
        allowed_methods = ['get']
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()
        include_resource_uri = False
        ordering = 'id'

    def build_filters(self, filters=None):
        if not filters.get(u'quiz_id', False):
            raise BadRequest("Invalid data sent: quiz__id is mandatory parameter")

        orm_filters = super(QuizQuestionResource, self).build_filters(filters)
        orm_filters['quiz__id'] = filters.get(u'quiz_id')
        return orm_filters

    def dehydrate(self, bundle):
        question_object = bundle.obj
        answers = []
        for answer in question_object.answers.all().order_by("id"):
            answers.append({'id': answer.id,
                            'text': answer.text,
                            'img_file': answer.img_file and answer.img_file.url,
                            'is_correct': answer.is_correct,
                            'order': answer.order})
        bundle.data['answers'] = answers

        # TODO: restrinctions for roles
        # args = managers in bundle.request.user.groups.all() and (
        #     'text', 'media_file', 'is_correct', ) or (
        #     'text', 'media_file', )

        return super(QuizQuestionResource, self).dehydrate(bundle)


class QuizAssigmentResource(PutModelResource):

    parametr_list = [('presentation_id', 'quiz__presentation_id', ),
                     ('user', 'user', ), ('quiz_id', 'quiz_id', )]
    # valid_list = [('quiz__presentation_id', ), ('quiz_id', ), []]

    class Meta:
        queryset = QuizAssigment.objects.all()
        resource_name = 'quiz_assignment_resource'
        allowed_methods = ['get', 'post']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = AllAuthorization()

    def get_object_list(self, request=None):
        result = super(QuizAssigmentResource, self).get_object_list(request)
        method = request.method.lower()
        if method == 'get':
            result = result.filter(user=request.user)
        if method == 'post':
            result = result
        return result

    def post_list(self, request, **kwargs):
        kwargs.update({'user_id': request.usuller.id})
        return super(QuizAssigmentResource, self).post_list(request, **kwargs)

    def dehydrate(self, bundle):
        bundle.data['quiz_id'] = bundle.obj.quiz_id
        return super(QuizAssigmentResource, self).dehydrate(bundle)


class QuizResultsResource(PutModelResource):

    class Meta:
        queryset = QuizResults.objects.all()
        resource_name = 'quiz_results_resource'
        allowed_methods = ['post']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = AllAuthorization()

    def post_list(self, request, **kwargs):
        deserialized = self.deserialize(
            request, request.raw_post_data, format=request.META.get(
                'CONTENT_TYPE', 'application/json'))
        deser = self.alter_deserialized_detail_data(request, deserialized)
        try:
            QuizResults.clear(deser['quiz_question_id'],
                              deser['quiz_assigment_id'],
                              deser['quiz_question_answer_id'])
        except IntegrityError:
            raise BadRequest("Invalid data sent.")

        return super(QuizResultsResource, self).post_list(request, **kwargs)


class VideoGroupResource(ModelResource):
    vendor_group = fields.ToOneField(VendorGroupResource, 'vendor_group',
                                     null=True)

    class Meta:
        queryset = VideoGroup.objects.all()
        resource_name = 'video_group_resource'
        allowed_methods = ['get']
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()
        include_resource_uri = False
        fields = ['id', 'name', 'parent', 'vendor_group', 'thumb']
        serializer = CustomSerializer()
        filtering = {'id': ALL,
                     'vendor_group': ALL_WITH_RELATIONS}

    def dehydrate(self, bundle):
        parent = bundle.obj.parent
        if parent:
            parent = parent.id
        vendor_group = bundle.obj.vendor_group
        if vendor_group:
            vendor_group = vendor_group.id

        bundle.data['parent_id'] = parent
        bundle.data['vendor_group_id'] = vendor_group
        del bundle.data['vendor_group']

        language = bundle.request.GET.get('language_code', def_lang.code)
        obj = bundle.obj
        obj_translation = obj.videogrouptranslation_set.filter(language__code=language)
        if not obj_translation:
            obj_translation = obj.videogrouptranslation_set.get(language__code=def_lang.code)
        else:
            obj_translation = obj_translation[0]

        bundle.data['name'] = obj_translation.name

        return super(VideoGroupResource, self).dehydrate(bundle)


class VideoResource(ModelResource):
    video_group = fields.ToOneField(VideoGroupResource, 'video_group')

    class Meta:
        queryset = Video.objects.all()
        resource_name = 'video_resource'
        allowed_methods = ['get']
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()
        serializer = CustomSerializer()
        include_resource_uri = False
        filtering = {'id': ALL,
                     'video_group': ALL_WITH_RELATIONS}

    def dehydrate(self, bundle):
        del bundle.data['video_group']
        bundle.data['video_group_id'] = bundle.obj.video_group.id

        language = bundle.request.GET.get('language_code', def_lang.code)
        obj = bundle.obj
        obj_translation = obj.videotranslation_set.filter(language__code=language)
        if not obj_translation:
            obj_translation = obj.videotranslation_set.get(language__code=def_lang.code)
        else:
            obj_translation = obj_translation[0]

        bundle.data['name'] = obj_translation.name
        convertvideo = []
        for item in obj.convertvideo_set.values():
            item['source'] = os.path.join(settings.MEDIA_URL, item['source'])
            convertvideo.append(item)
        bundle.data['converted_video'] = tuple(convertvideo)

        return super(VideoResource, self).dehydrate(bundle)


class ContentPagesResource(ModelResource):

    class Meta:
        queryset = InfoPage.objects.all()
        resource_name = 'content_pages_resource'
        allowed_methods = ['get']
        include_resource_uri = False

    def dehydrate(self, bundle):
        language = bundle.request.GET.get('language_code', def_lang.code)
        obj = bundle.obj
        obj_translation = obj.infopagetranslation_set.filter(language__code=language)
        if not obj_translation:
            obj_translation = obj.infopagetranslation_set.filter(language__code=def_lang.code)

        bundle.data.update(obj_translation.values()[0])
        del bundle.data['language_id']
        bundle.data['language__code'] = obj_translation[0].language.code
        return super(ContentPagesResource, self).dehydrate(bundle)

    def build_filters(self, filters=None):
        if not filters.get('vendor_id', False):
            raise BadRequest("Invalid data sent. 'vendor_id' is mandatory parameter")

        orm_filters = super(ContentPagesResource, self).build_filters(filters)
        orm_filters['vendor__id'] = filters['vendor_id']

        return orm_filters


class SeminarResource(PutModelResource):

    parametr_list = [('vendor_id', 'vendor_id', ),
                     ('seminar_id', 'id', ),
                     ('name', 'name', ),
                     ('note', 'note', ),
                     ('language_code', 'language__code', )]
    valid_list = [('vendor_id', 'language__code', ), ('id', ), []]

    class Meta:
        queryset = Seminar.objects.all()
        resource_name = 'seminar_resource'
        allowed_methods = ['get', 'post', 'put', 'delete']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()

    def get_object_list(self, request=None):
        result = super(SeminarResource, self).get_object_list(request)
        result = result.filter(user=request.user)
        return result

    def post_list(self, request, **kwargs):
        deserialized = self.deserialize(
            request, request.raw_post_data, format=request.META.get(
                'CONTENT_TYPE', 'application/json'))
        deserialized = self.alter_deserialized_detail_data(request,
                                                           deserialized)
        bundle = self.build_bundle(data=dict_strip_unicode_keys(deserialized),
                                   request=request)
        kwargs.update(deserialized)
        kw = self.remove_api_resource_names(kwargs)

        try:
            language = Language.objects.get(code=kw.get('language_code', request.LANGUAGE_CODE))
        except ObjectDoesNotExist:
            raise BadRequest("Invalid data sent, language_code is mandatory parameter")

        kw.update({'language': language, 'user': request.user})

        self.is_valid(bundle, request)
        updated_bundle = self.obj_create(bundle, request=request, **kw)
        location = self.get_resource_uri(updated_bundle)
        updated_bundle = self.full_dehydrate(updated_bundle)
        updated_bundle = self.alter_detail_data_to_serialize(request,
                                                             updated_bundle)
        return self.create_response(request, updated_bundle, location=location,
                                    response_class=http.HttpCreated)

    def dehydrate(self, bundle):
        seminar_id = bundle.request.GET.get('seminar_id', False)
        if seminar_id:
            seminar_content = SeminarContentItem.objects.filter(
                seminar_id=int(seminar_id))
            bundle.data['seminar content'] = []
            for item in seminar_content:
                content_object = item.content_object
                if isinstance(content_object, PresentationSlide):
                    slide = PresentationSlide.objects.filter(
                        id=content_object.id).values()[0]
                    slide.update({
                        'puppet_id': content_object.puppet_id,
                        'puppet_version': getattr(getattr(
                            content_object, 'puppet', None), 'version', None)})
                    slide['text_bloks'] = tuple(SlideTextBlock.objects.filter(
                        presentation_slide=slide['id']).values())
                    bundle.data['seminar content'].append(slide)

                elif isinstance(content_object, QuizQuestion):
                    questions = QuizQuestion.objects.filter(
                        id=content_object.id).values()

                    answers_data = []
                    for item in questions:
                        answer = QuizQuestionAnswer.objects\
                            .filter(question_id=item['id'])\
                            .values('text', 'sound', 'media_file')
                        answers_data.append(item.update({'answer': answer}))

                    questions[0].update({'answers': answers_data})
                    bundle.data['seminar content'].append(questions[0])

                elif isinstance(content_object, SeminarMedia):
                    seminar = SeminarMedia.objects.filter(
                        id=content_object.id).values()[0]
                    bundle.data['seminar content'].append(seminar)
        return super(SeminarResource, self).dehydrate(bundle)

    def put_list(self, request, **kwargs):
        deserialized = self.deserialize(
            request, request.raw_post_data, format='application/json')
        deserialized = self.alter_deserialized_list_data(request, deserialized)
        deserialized = {'objects': [deserialized]}
        bundles_seen = []
        for object_data in deserialized['objects']:
            if 'name' not in object_data or 'note' not in object_data:
                continue
            bundle = self.build_bundle(
                data=dict_strip_unicode_keys(object_data), request=request)
            try:
                self.is_valid(bundle, request)
            except ImmediateHttpResponse:
                self.rollback(bundles_seen)
                raise

            kw, kwargs = self.remove_api_resource_names(kwargs), {}
            'name' in kw and kwargs.update({'name': kw['name']})
            'note' in kw and kwargs.update({'note': kw['note']})
            self.obj_update(bundle, request=request, **kwargs)
            bundles_seen.append(bundle)

        if not self._meta.always_return_data:
            to_be_serialized = {}
            to_be_serialized['objects'] = [
                self.full_dehydrate(bundle) for bundle in bundles_seen]
            to_be_serialized = self.alter_list_data_to_serialize(
                request, to_be_serialized)
            return self.create_response(request, to_be_serialized,
                                        response_class=http.HttpAccepted)


class SeminarContentResource(PutModelResource):

    parametr_list = [('object_id', 'object_id', ),
                     ('object_type', 'content_type', ),
                     ('content_id', 'id', ),
                     ('name', 'name', ),
                     ('order', 'order', ),
                     ('seminar_id', 'seminar_id', )]
    valid_list = [('object_id', 'seminar_id', 'content_type', ),
                  ('seminar_id', ),
                  ('id', ), []]
    class_dict = {'slide': (PresentationSlide, 'title', ),
                  'media': (SeminarMedia, 'name', ),
                  'question': (QuizQuestion, 'text', )}

    class Meta:
        queryset = SeminarContentItem.objects.all()
        resource_name = 'seminar_content_resource'
        allowed_methods = ['get', 'post', 'put', 'delete']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()

    def into_post(self, request, **kwargs):
        kw = self.remove_api_resource_names(kwargs)
        obj_type = self.class_dict[kw.pop('object_type')]
        content_type = ContentType.objects.get_for_model(obj_type[0])
        kw['content_type_id'] = content_type.id
        kw.get('name', False) or kw.update({'name': getattr(
            obj_type[0].objects.get(id=int(kw['object_id'])), obj_type[1])})

        order = kw.get('order', False)
        if not order:
            order_d = self._meta.queryset.filter(seminar_id=int(kw['seminar_id'])).aggregate(Max('order'))
            if order_d['order__max'] is None:
                current_order = 1
            else:
                current_order = order_d['order__max'] + 1
            kw['order'] = current_order
        else:
            seminar_contents = self._meta.queryset.filter(
                seminar_id=int(kw['seminar_id']),
                order__gte=int(order)).order_by('order')
            for new_order, content in list(enumerate(list(seminar_contents))):
                content.order = new_order + int(order) + 1
                content.save()
        return kw

    def _normalize(self, content_id, seminar_id=None):
        try:
            content = self._meta.queryset.get(id=content_id)
            seminar_id = content.seminar_id
        except ObjectDoesNotExist:
            seminar_id = seminar_id
        contents = self._meta.queryset.filter(
            seminar_id=seminar_id).order_by('order')
        for new_order, sem_content in list(enumerate(list(contents))):
            sem_content.order = new_order
            sem_content.save()

    def put_list(self, request, **kwargs):
        deserialized = self.deserialize(
            request, request.raw_post_data, format='application/json')
        deserialized = self.alter_deserialized_list_data(request, deserialized)
        deserialized = {'objects': [deserialized]}
        bundles_seen = []
        for object_data in deserialized['objects']:
            order = object_data.get('order', False)
            if order:
                try:
                    order = int(order)
                except:
                    order = 'normal'

                content_id = int(request.GET['content_id'])
                content = self._meta.queryset.get(id=content_id)
                order_content = content.order

                if order == 'normal':
                    self._normalize(content_id)
                    object_data = {'order': str(
                        self._meta.queryset.get(id=content_id).order)}
                elif order_content > order:
                    contents = self._meta.queryset.filter(
                        order__gte=order, seminar_id=content.seminar_id,
                        order__lt=order_content).order_by('order')
                    for item in contents:
                        item.order += 1
                        item.save()
                elif order_content < order:
                    contents = self._meta.queryset.filter(
                        order__lte=order, seminar_id=content.seminar_id,
                        order__gt=order_content).order_by('order')
                    for item in contents:
                        item.order -= 1
                        item.save()

            bundle = self.build_bundle(
                data=dict_strip_unicode_keys(object_data), request=request)
            try:
                self.is_valid(bundle, request)
            except ImmediateHttpResponse:
                self.rollback(bundles_seen)
                raise
            self.obj_update(bundle, request=request,
                            **self.remove_api_resource_names(kwargs))
            bundles_seen.append(bundle)

        if not self._meta.always_return_data:
            to_be_serialized = {}
            to_be_serialized['objects'] = [
                self.full_dehydrate(bundle) for bundle in bundles_seen]
            to_be_serialized = self.alter_list_data_to_serialize(
                request, to_be_serialized)
            return self.create_response(request, to_be_serialized,
                                        response_class=http.HttpAccepted)

    def obj_delete_list(self, request=None, **kwargs):
        content_id = int(request.GET['content_id'])
        content = self._meta.queryset.get(id=content_id)
        super(SeminarContentResource, self).obj_delete_list(request, **kwargs)
        self._normalize(content_id, content.seminar_id)

    def dehydrate(self, bundle):
        # TODO: fix it later
        content_object = bundle.obj.content_object
        if content_object is not None:
            bundle.data['content_object'] = {"audio_notes": content_object.audio_notes,
                                         "id": str(content_object.id),
                                         "image_map": content_object.image_map,
                                         "is_visible": content_object.is_visible,
                                         "order": content_object.order,
                                         "presentation_id": str(content_object.presentation.id),
                                         "puppet_id": content_object.puppet_id,
                                         "puppet_sound": content_object.puppet_sound.url if content_object.puppet_sound else content_object.puppet_sound,
                                         "puppet_text": content_object.puppet_text,
                                         "puppet_version": content_object.puppet.version,
                                         "sound": content_object.sound.url if content_object.sound else content_object.sound,
                                         "source": content_object.source.url if content_object.source else content_object.source,
                                         "special_slide_tags": content_object.special_slide_tags,
                                         "special_title_tags": content_object.special_title_tags,
                                         "text": content_object.text,
                                         "text_bloks": [{"id": t.id,
                                                         "order": t.order,
                                                         "presentation_slide_id": t.presentation_slide_id,
                                                         "text": t.text} for t in content_object.slidetextblock_set.all()],
                                         "title": content_object.title,
                                         "translation_status": content_object.translation_status}

        return super(SeminarContentResource, self).dehydrate(bundle)


class SeminarMediaResource(PutModelResource):

    parametr_list = [('name', 'name', ),
                     ('file', 'media_file', ),
                     ('media_id', 'id', )]
    valid_list = [('name', 'media_file', ), ('id', ), []]

    class Meta:
        queryset = SeminarMedia.objects.all()
        resource_name = 'seminar_media_resource'
        allowed_methods = ['get', 'post', 'put', 'delete']
        serializer = CustomSerializer()
        authentication = DjangoAuthentication()
        authorization = DjangoAuthorization()

    def get_object_list(self, request=None):
        result = super(SeminarMediaResource, self).get_object_list(request)
        result = result.filter(user=request.user)
        return result

    def into_post(self, request, **kwargs):
        kw = self.remove_api_resource_names(kwargs)
        kw.update({'user_id': request.user.id})
        return kw
